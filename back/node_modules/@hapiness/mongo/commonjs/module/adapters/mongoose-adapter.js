"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose = require("mongoose");
const Observable_1 = require("rxjs/Observable");
const hapiness_mongo_adapter_1 = require("./hapiness-mongo-adapter");
const shared_1 = require("../shared");
const __debugger = new shared_1.Debugger('MongooseAdapter');
mongoose.Promise = global.Promise;
class MongooseAdapter extends hapiness_mongo_adapter_1.HapinessMongoAdapter {
    static getInterfaceName() {
        return 'mongoose';
    }
    constructor(options) {
        super(options);
        this.on('error', (...args) => __debugger.debug('on#error', JSON.stringify(args)));
    }
    _tryConnect() {
        return Observable_1.Observable
            .create(observer => {
            this._isReady = false;
            const connectOptions = {
                promiseLibrary: global.Promise,
                reconnectTries: Number.MAX_VALUE,
                reconnectInterval: 5000,
            };
            this._connection = mongoose.createConnection(this._uri, connectOptions);
            this._connection.on('connected', () => {
                __debugger.debug('on#connected', `connected to ${shared_1.UtilFunctions.hideCredentials(this._uri)}`);
                this.emit('connected', { uri: this._uri });
            });
            this._connection.on('reconnectFailed', () => {
                __debugger.debug('on#reconnectFailed', `reconnectFailed on ${shared_1.UtilFunctions.hideCredentials(this._uri)}`);
                this.emit('reconnectFailed', { uri: this._uri });
            });
            // Seems that typings are not up to date at the moment
            this._connection['then'](() => {
                observer.next();
                observer.complete();
            })
                .catch(err => observer.error(err));
        });
    }
    _afterConnect() {
        return Observable_1.Observable
            .create(observer => {
            this.onConnected().subscribe(_ => {
                __debugger.debug('_afterConnect', '(subscribe) On connected success');
            }, (e) => {
                __debugger.debug('_afterConnect', `(subscribe) On connected failed ${JSON.stringify(e, null, 2)}`);
                this.emit('error', e);
            });
            this._connection.on('error', (...args) => this.emit('error', ...args));
            this._connection.on('disconnected', () => {
                __debugger.debug('on#disconnected', `disconnected from ${shared_1.UtilFunctions.hideCredentials(this._uri)}`);
                this.emit('disconnected', { uri: this._uri });
            });
            observer.next();
            observer.complete();
        });
    }
    getLibrary() {
        return mongoose;
    }
    getConnection() {
        return this._connection;
    }
    registerValue(schema, collection, collectionName) {
        if (collectionName && collectionName.length) {
            return this._connection.model(collection, schema, collectionName);
        }
        return this._connection.model(collection, schema);
    }
    close() {
        return Observable_1.Observable.fromPromise(this._connection.client.close());
    }
}
exports.MongooseAdapter = MongooseAdapter;
//# sourceMappingURL=mongoose-adapter.js.map