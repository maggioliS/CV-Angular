"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const adapters_1 = require("../adapters");
const shared_1 = require("../shared");
const Observable_1 = require("rxjs/Observable");
const __debugger = new shared_1.Debugger('MongoManager');
class MongoManager {
    constructor(config) {
        this._config = this._fixConfig(config);
        this._adaptersInstances = {};
        this._adapters = {
            [adapters_1.MongooseAdapter.getInterfaceName()]: adapters_1.MongooseAdapter,
            [adapters_1.MongooseGridFsAdapter.getInterfaceName()]: adapters_1.MongooseGridFsAdapter,
            [adapters_1.MongooseGridFsBucketAdapter.getInterfaceName()]: adapters_1.MongooseGridFsBucketAdapter
        };
    }
    _fixConfig(configValues) {
        __debugger.debug('_fixConfig', '');
        return Object.assign({}, configValues);
    }
    _keyForAdapter(adapterName, options) {
        __debugger.debug('_keyForAdapter', '');
        if (options.connectionName) {
            return options.connectionName;
        }
        const usedKeyForKeyComputation = ['db', 'database', 'url', 'instance'];
        const _keyElements = [adapterName].concat(Object.keys(options).reduce((acc, k) => {
            if (usedKeyForKeyComputation.indexOf(k) !== -1) {
                return acc.concat(options[k]);
            }
            return acc;
        }, []));
        return _keyElements.join('_');
    }
    registerAdapter(adapterClass) {
        __debugger.debug('registerAdapter', '');
        const adapterName = adapterClass.getInterfaceName();
        __debugger.debug('registerAdapter', `---->  ${adapterName}`);
        if (!this._adapters[adapterName]) {
            this._adapters[adapterName] = adapterClass;
        }
        else {
            throw new Error(`Provider ${adapterName} already exists.`);
        }
        return true;
    }
    loadAdapter(adapterName, options) {
        __debugger.debug('loadAdapter', `Adapter name ---> ${adapterName}`);
        if (!this._adapters[adapterName]) {
            return Observable_1.Observable.throw(new Error(`Unknown adapter ${adapterName}, please register it before using it.`));
        }
        const _options = Object.assign({}, this._config, options);
        const key = this._keyForAdapter(adapterName, _options);
        if (!this._adaptersInstances[key]) {
            this._adaptersInstances[key] = new (this._adapters[adapterName])(_options);
        }
        return this
            ._adaptersInstances[key]
            .connect()
            .flatMap(() => this._adaptersInstances[key].whenReady())
            .map(_ => this._adaptersInstances[key]);
    }
    getAdapter(adapterName, options) {
        __debugger.debug('getAdapter', `Adapter name ---> ${adapterName}`);
        const _options = Object.assign({}, this._config, options);
        // If there is only one registered provider for the wanted adapter, dont compute the key but return it directly
        let key = '';
        const _keysForAdapterInstances = Object.entries(this._adaptersInstances)
            .filter(([k, v]) => v.constructor.getInterfaceName() === adapterName)
            .map(([k]) => k);
        if (_keysForAdapterInstances.length === 1) {
            key = _keysForAdapterInstances.shift();
        }
        else {
            key = this._keyForAdapter(adapterName, _options);
        }
        return this._adaptersInstances[key];
    }
}
exports.MongoManager = MongoManager;
//# sourceMappingURL=mongo-manager.js.map